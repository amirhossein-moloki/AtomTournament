# تحلیل جامع Backend و API: گزارش نهایی

## مقدمه
این گزارش نتیجه تحلیل جامع و عمیق کل پروژه Backend و API است. هدف اصلی این تحلیل، شناسایی و ریشه‌یابی مشکلات احتمالی بود که می‌توانند منجر به خطاهای `400 Bad Request`، رفتار غیرقابل پیش‌بینی API، و ناسازگاری‌های دیگر شوند. تمرکز ویژه‌ای بر روی مشکل گزارش‌شده مبنی بر "درخواست‌های PATCH با داده یکسان که گاهی موفق و گاهی ناموفق هستند" قرار گرفت.

## خلاصه یافته‌ها
ریشه اصلی مشکل خطاهای 400 متناوب، یک **ناهماهنگی بین کلاینت (فرانت‌اند) و یک مکانیزم سخت‌گیرانه برای اعتبارسنجی فایل در بک‌اند** است. یک `File Upload Handler` سفارشی در بک‌اند به نام `SafeFileUploadHandler` وجود دارد که هرگونه فایل با `Content-Type` غیرمجاز را بلافاصله رد می‌کند. مشکل زمانی رخ می‌دهد که کلاینت (فرانت‌اند)، به دلیل یک باگ یا منطق پیش‌بینی نشده، در درخواست‌های `multipart/form-data`، فیلد فایل را با داده‌های نامعتبر (مثلاً `Content-Type` اشتباه) ارسال می‌کند، حتی اگر کاربر قصدی برای آپلود فایل جدید نداشته باشد.

---

## 1. بررسی API و Endpointها
- **تمام مسیرهای API** بررسی شدند و ساختار کلی آن‌ها منطقی و استاندارد است.
- **دلیل اصلی خطاهای 400**، `tournaments.upload_handlers.SafeFileUploadHandler` است. این `handler` قبل از رسیدن درخواست به `View`، آن را بررسی کرده و در صورت نامعتبر بودن نوع (`Content-Type`) یا حجم فایل، آپلود را متوقف کرده و از طریق `UploadErrorHandlerMiddleware` یک پاسخ `400` برمی‌گرداند.
- **فیلدها در Serializerها** به درستی تعریف شده‌اند، اما در برخی موارد (مانند `MatchUpdateSerializer`) یک لایه اعتبارسنجی اضافه بر روی فیلد فایل وجود دارد که می‌تواند با اعتبارسنجی `SafeFileUploadHandler` تفاوت داشته باشد و باعث سردرگمی شود (مثلاً `handler` به `image/webp` اجازه عبور می‌دهد اما `Serializer` آن را رد می‌کند).
- **رفتار `partial_update` (PATCH)** دقیقاً همان جایی است که مشکل بروز می‌کند. از آنجایی که در `PATCH` تمام فیلدها اختیاری هستند، انتظار می‌رود که اگر فیلد فایل ارسال نشود، نادیده گرفته شود. اما مشکل اینجاست که فرانت‌اند به جای "ارسال نکردن" فیلد، آن را با "داده نامعتبر" ارسال می‌کند.
- **مسیرها** مشکلی از نظر trailing slash یا حساسیت به حروف ندارند.

## 2. بررسی Models و Database
- **ارتباطات مدل‌ها**، کلیدهای خارجی و محدودیت‌ها به درستی پیاده‌سازی شده‌اند.
- **وضعیت رکوردها** در دیتابیس تاثیری بر خطای 400 متناوب ندارد، زیرا خطا قبل از دسترسی به دیتابیس و در لایه `Upload Handler` رخ می‌دهد.
- **احتمال Race Condition** در این سناریوی خاص رد می‌شود، زیرا منشأ خطا به وضعیت خارجی وابسته نیست.

## 3. بررسی Views و Serializers
- **Views و ViewSetها** به درستی منطق بیزنس را به لایه سرویس یا `Serializer`ها واگذار کرده‌اند و ساختار تمیزی دارند.
- **Serializerها** به درستی کار اعتبارسنجی را انجام می‌دهند، اما مشکل اصلی قبل از رسیدن داده به `Serializer` رخ می‌دهد.
- **Middlewareها**: `UploadErrorHandlerMiddleware` نقش کلیدی در تبدیل خطای `StopUpload` به پاسخ `400` دارد و به درستی کار خود را انجام می‌دهد. مشکل در `handler` است، نه `middleware`.

## 4. بررسی Authentication و Permissions
- سیستم احراز هویت مبتنی بر `JWT` و کاملاً استاندارد است.
- **کلاس‌های Permission** به درستی کار می‌کنند و در صورت عدم دسترسی، خطای `403 Forbidden` برمی‌گردانند، نه `400 Bad Request`. بنابراین، این بخش منشأ مشکل نیست.

## 5. بررسی Server و کانفیگ
- **کانفیگ Nginx** بررسی شد. وجود `client_max_body_size 20M` می‌تواند باعث خطای `413 Payload Too Large` برای فایل‌های حجیم شود که باید به آن توجه داشت.
- مکانیزم‌های Caching و Rate Limiting در Nginx می‌توانند باعث رفتارهای غیرمنتظره دیگری (مانند کندی یا خطای `503`) شوند، اما دلیل خطای `400` نیستند.
- **هدر `Referrer-Policy: origin-when-cross-origin`** یک سیاست امنیتی استاندارد است و یک خطا محسوب نمی‌شود.

## 6. تحلیل تکرارپذیری درخواست‌ها
- **چرا درخواست‌های PATCH با داده یکسان گاهی موفق و گاهی 400 می‌شوند؟**
  زیرا داده‌ها "یکسان" نیستند. اگرچه از دید کاربر ممکن است تغییری ایجاد نشده باشد، اما کلاینت (فرانت‌اند) در پشت صحنه، بدنه درخواست (`request body`) متفاوتی را تولید و ارسال می‌کند. در درخواست موفق، فیلد فایل اصلاً ارسال نمی‌شود. در درخواست ناموفق، فیلد فایل با `Content-Type` نامعتبر یا داده خراب ارسال می‌شود که بلافاصله توسط `SafeFileUploadHandler` رد می‌شود.

---

## 7. ارائه راهکار

### راه‌حل‌های پیشنهادی (کوتاه مدت)

1.  **مقاوم‌سازی بک‌اند (راه‌حل فوری و ضروری)**:
    - **علت**: `SafeFileUploadHandler` بیش از حد سخت‌گیر است و برای ورودی‌های غیرمنتظره از سمت کلاینت شکننده است.
    - **راه‌حل**: منطق `SafeFileUploadHandler` را تغییر دهید تا در مقابل داده‌های نامعتبر مقاوم باشد. به جای رد کردن کل درخواست، باید فیلدهای فایل "خالی" یا "نامعتبر" را نادیده بگیرد.
    - **مثال پیاده‌سازی در `upload_handlers.py`**:
      ```python
      # در متد new_file در کلاس SafeFileUploadHandler
      def new_file(self, *args, **kwargs):
          super().new_file(*args, **kwargs)

          # اگر Content-Type وجود ندارد یا در لیست مجاز نیست
          if self.content_type not in self.allowed_content_types:
              # بررسی کنید که آیا فایل واقعا محتوا دارد یا فقط یک فیلد خالی است
              # (این چک کردن ممکن است نیاز به کمی آزمون و خطا داشته باشد)
              if self.file_name or self.content_length > 0:
                  error_message = {"error": {"message": "Invalid file type."}}
                  self.request.upload_error = JsonResponse(error_message, status=400)
                  raise StopUpload(connection_reset=True)
              else:
                  # اگر فیلد خالی است، آن را نادیده بگیر و به پردازش ادامه بده
                  self.active = False
                  return
      ```

2.  **بهبود لاگ‌گیری در بک‌اند**:
    - **علت**: مشخص نیست دقیقاً چه `Content-Type` ای از سمت کلاینت ارسال می‌شود که باعث خطا میگردد.
    - **راه‌حل**: در `UploadErrorHandlerMiddleware` یا `SafeFileUploadHandler`، قبل از ارسال پاسخ 400، اطلاعات کامل درخواست (مانند `Content-Type`, `Content-Length` و `file_name`) را لاگ کنید. این کار دیباگ کردن مشکلات آینده را بسیار ساده‌تر می‌کند.

3.  **اصلاح باگ در فرانت‌اند (ریشه اصلی مشکل)**:
    - **علت**: منطقی در فرانت‌اند وجود دارد که داده‌های فایل نامعتبر ارسال می‌کند.
    - **راه‌حل**: کد فرانت‌اند مربوط به فرم‌هایی که آپلود فایل دارند باید بازبینی شود. منطق باید به این صورت اصلاح شود:
        - اگر کاربر فایل جدیدی را انتخاب **نکرده** است، در درخواست `PATCH` فیلد مربوط به فایل **اصلاً نباید وجود داشته باشد**.
        - کتابخانه‌های مدیریت فرم یا آپلود فایل در فرانت‌اند را بررسی کنید تا مطمئن شوید که در حالت "بدون تغییر" (pristine) داده‌ای ارسال نمی‌کنند.

### پیشنهادات برای بهبود پایداری (بلند مدت)

1.  **ایجاد قرارداد API واضح (API Contract)**:
    - `Content-Type` های مجاز برای هر Endpoint آپلود را به صورت واضح در مستندات API (Swagger/Spectacular) مشخص کنید.

2.  **هماهنگ‌سازی لایه‌های اعتبارسنجی**:
    - `SafeFileUploadHandler` به `webp` اجازه می‌دهد اما `MatchUpdateSerializer` نه. این ناهماهنگی را برطرف کنید. تمام لایه‌های اعتبارسنجی باید از یک منبع حقیقت واحد (single source of truth) برای قوانین استفاده کنند.

3.  **افزودن تست‌های یکپارچه‌سازی (Integration Tests)**:
    - تست‌هایی بنویسید که سناریوهای مختلف آپلود فایل را شبیه‌سازی کنند، از جمله ارسال فرم بدون فایل، با فایل معتبر، و با فایل نامعتبر تا از رفتار صحیح بک‌اند در تمام حالات اطمینان حاصل شود.
